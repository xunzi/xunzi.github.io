<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.90.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Blog&nbsp;&ndash;&nbsp;Bloggggggg</title><link rel="stylesheet" href="/css/core.min.9e958365cf0319ede466a402e1369f31dc1f205c868aa836fe25581725c829d3f3545d9f142cccafe35363950a63e2a6.css" integrity="sha384-npWDZc8DGe3kZqQC4TafMdwfIFyGiqg2/iVYFyXIKdPzVF2fFCzMr&#43;NTY5UKY&#43;Km"><link rel="alternate" type="application/rss+xml" href="/post/index.xml" title="Bloggggggg" /><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Blog" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/images/wolken.jpg" alt /><span class="site name">Bloggggggg</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank" rel="noopener noreferrer">Hugo</a><a class="nav item" href="https://github%2ecom/xunzi"target="_blank" rel="noopener noreferrer">Github</a><a class="nav item" href="https://twitter%2ecom/xunzi"target="_blank" rel="noopener noreferrer">Twitter</a></nav></div></span></div><div class="site slogan"><span class="title">100% JavaScript-free</span></div></section><section id="content"><section class="article header"><h1>Blog</h1></section><ul class="note list"><li class="item"><a class="note" href="/post/pelican2hugo/">
            <p class="note title">Pelican2Hugo</p><p class="note date">2021-12-27</p><p class="note content">Das Blog ist wieder mal auf eine neue Plattform umgezogen, es bleibt bei einem static site generator, aber statt Pelican ist jetzt Hugo am Start.
Die Artikel sind nach wie vor in Markdown verfasst, so dass hier keine Umwandlung notwendg ist, einzig die Headers/Front Matter sind in einem neuen Format.
Ich habe ein Conversionsskript geschrieben, das die Frontmatter von Pelican ins Hugo-Format umwandelt.</p></a><p class="note labels"><a class="tag" href="/tags/pelican/">pelican</a><a class="tag" href="/tags/hugo/">hugo</a><a class="tag" href="/tags/blog/">blog</a></p></li><li class="item"><a class="note" href="/post/terraform-und-lxd/">
            <p class="note title">Terraform und Lxd</p><p class="note date">2021-12-25</p><p class="note content">Terraform ist eine deklarative Beschreibungssprache für Cloud-Infrastrukturen.
Unterstützt werden viele Cloudprovider, unter anderem auch lxd.
Ein kleines Beispiel für das Deployment von zwei lxd-Containern mit PostgreSQL:
terraform { required_providers { lxd = { source = &#34;terraform-lxd/lxd&#34; version = &#34;1.6.0&#34; } } } provider &#34;lxd&#34; { generate_client_certificates = true accept_remote_certificate = true lxd_remote { name = &#34;rpi4-8gb&#34; scheme = &#34;https&#34; address = &#34;10.10.10.1&#34; password = &#34;sowasvongeheim&#34; default = true } } resource &#34;lxd_cached_image&#34; &#34;focal&#34; { source_remote = &#34;ubuntu&#34; source_image = &#34;ed6764dcaa08&#34; } resource &#34;lxd_container&#34; &#34;pg&#34; { name = &#34;pg0${count.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/terraform/">terraform</a><a class="tag" href="/tags/lxd/">lxd</a></p></li><li class="item"><a class="note" href="/post/kvm-zu-lxd/">
            <p class="note title">KVM zu LXD</p><p class="note date">2018-10-07</p><p class="note content">Alle vier Jahre migrieren wir den Hetzner-Server auf neue Hardware, bei der letzten Umstellung haben wir auch gleich den Unterbau geändert, wo früher die individuellen Gäste als kvm/libvirt-Gäste liefen und die Infrastruktur (Datenbanken, Verzeichnisdienst, Email) auf dem Host, sind jetzt alle Funktionen in Lxd -Container ausgelagert.
Lxd-Container stellen sich wie ein vollwertiges Betriebssystem dar, mir persönlich sind Docker-Container zu friemelig, der Unix-Admin in mir stört sich einfach daran, dass man bei Docker nicht so einfach mit der Shell rumporkeln kann, bis es geht.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/kvm/">kvm</a><a class="tag" href="/tags/rootserver/">rootserver</a><a class="tag" href="/tags/lxd/">lxd</a></p></li><li class="item"><a class="note" href="/post/virsh-disk-handling/">
            <p class="note title">Virsh disk handling</p><p class="note date">2018-07-02</p><p class="note content">Wenn die qemu/kvm-Platten vollaufen, kann man relativ einfach eine neue Platte erzeugen und mounten. Das ist in vielen Fällen weniger kritisch, als existierende Diskimages, Partitionen und Dateisysteme zu vergrößern.
 Neue Platte erzeugen  Eine neues Diskimage (im qcow2-Format, siehe Diskussion zu den Unterschieden der beiden Formate, qcow2 ist angeblich langsamer, bietet aber Snapshots) kann man folgendrmaßen erstellen:
[0]next:{1026}~% export format=&#34;qcow2&#34; [0]next:{1026}~% export your_vm_name=&#34;somename&#34; [0]next:{1026}~% qemu-img create -f $format $your_vm_name-128G.qcow2 128G Für Images im Raw-Format einfach die erste Zeile so umschreiben:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/virsh/">virsh</a><a class="tag" href="/tags/blockdevice/">blockdevice</a><a class="tag" href="/tags/qemu-img/">qemu-img</a></p></li><li class="item"><a class="note" href="/post/dot-tumxconf/">
            <p class="note title">Dottmuxconf</p><p class="note date">2016-07-18</p><p class="note content">Tmux-Konfig mit grüner Statusleite und veränderten Keybinding.
unbind C-b set -g prefix C-g bind C-g send-prefix bind g send-prefix set-window-option -g window-status-current-style bg=red # Set window notifications setw -g monitor-activity on set -g visual-activity on setw -g automatic-rename #emacs key bindings of course set-window-option -g mode-keys emacs set -g history-limit 10000 set -g default-terminal &quot;xterm-256color&quot; set -g base-index 1 set -g status-interval 2 Eine Kopie dieser Datei findet Ihr auf github .<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/tmux/">tmux</a><a class="tag" href="/tags/dotfiles/"> dotfiles</a></p></li><li class="item"><a class="note" href="/post/umstellung-auf-https/">
            <p class="note title">Umstellung auf https</p><p class="note date">2016-02-08</p><p class="note content">Da es dank Let&rsquo;s Encrypt jetzt auch https-Zertifikate für lau gibt, die in allen Browsern akzeptiert werden, habe ich dieses Blog dann auch mal auf https umgestellt. Hierfür benötigt man nur den Letsencrypt-Client, dann ist das Ganze in 2 Minuten umgesetzt. Ergänzt um einen Redirect von http auf https ist die Seite jetzt ganz den neuen Google-Siteranking-Kriterien entsprechend gesichert.
Der SSL Server Test vergibt für die Konfig sogar ein A+.</p></a><p class="note labels"><a class="tag" href="/tags/web/">web</a></p></li><li class="item"><a class="note" href="/post/dot-zshrc/">
            <p class="note title">Dotzsh</p><p class="note date">2015-09-07</p><p class="note content">Im Laufe der Jahre gewachsene Zsh-Konfig.
# Enable compsys completion. bindkey -e setopt NO_BEEP SHARE_HISTORY HIST_IGNORE_ALL_DUPS autoload -U compinit compinit if [[ -o interactive ]] ; then PS1='%(?.[%?].%S[%?]%s)%B%m%b:{%!}%~%# ' alias l='ls -l' #alias ls='ls --color=auto' fi HISTSIZE=1000 SAVEHIST=1000 HISTFILE=~/.history.zsh #pip only in virtualenv	export PIP_REQUIRE_VIRTUALENV=true export PIP_DOWNLOAD_CACHE=~/.pip/cache # function myssh { if [[ &quot;x$TMUX&quot; != &quot;x&quot; ]] ; then print -P &quot;Ssh to %B$1%b&quot; d=$(date '+%s') tmux neww -n $1 &quot;script -q logs/$1-$d.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/zsh/">zsh</a><a class="tag" href="/tags/dotfiles/"> dotfiles</a></p></li><li class="item"><a class="note" href="/post/bildergalerien-mit-sigal/">
            <p class="note title">Bildergalerien mit Sigal</p><p class="note date">2014-07-19</p><p class="note content">Die gelegentlich anfallenden Fotos aus dem Freunds- und Familienkreis habe ich bisher ärgerlicherweise bei Google hochgeladen udn mit einem privaten Link verteilt, so dass sie zwar nicht einer Google-Suche zum Opfer fallen können, aber dennoch bei Google bekannt sind. Viele Leute sind nachvollziehbarerweise auch gar nicht glücklich darüber, wenn sie ihr Antlitz auf einer bei Google gehosteten Seite wiederfinden, so dass hier eine neue Lösung hermusste. Da ich ja das Blog schon mit Pelican auf einen Generator für statische Webseiten umgestellt habe, lag es natürlich nahe, auch die Fotos mit einem solchen Generator in die Webseite einzubinden.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/web/">web</a><a class="tag" href="/tags/photos/">photos</a></p></li><li class="item"><a class="note" href="/post/streiche-mezzanine-setze-pelican/">
            <p class="note title">Streiche Mezzanine, setze Pelican</p><p class="note date">2013-11-30</p><p class="note content">Da Mezzanines Funktionsumfang für meine bescheidenen Bedürfnisse doch zu groß war, habe ich das Blog auf Pelican umgestellt, einen Generator für statische Webseiten. Denn Text kann man in reStructuredText oder Markdown verfassen und es gibt eine große Auswahl an Themes und Plugins , so dass bei Bedarf das Aussehen des Blogs schnell mal umgestellt werden kann. Ein weiterer Vorteil ist, dass die Inhalte dann einfach unter Versionskontrolle gestellt werden können, es sind ja nur Textdateien.<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/web/">web</a><a class="tag" href="/tags/rootserver/">rootserver</a><a class="tag" href="/tags/mezzanine/">mezzanine</a><a class="tag" href="/tags/pelican/">pelican</a></p></li><li class="item"><a class="note" href="/post/blogtransfer-von-pebble-zu-mezzanine/">
            <p class="note title">Blogtransfer von Pebble zu Mezzanine</p><p class="note date">2013-05-13</p><p class="note content">Die Umsetzung der alten Blogposts aus Pebble erfolgte mit Hilfe eines Skripts, das die xml-Dateien parst und entsprechende Mezzanine/Django-Objeckte anlegt inkl. Tags und Kategorien.
Das Skript gibt es als Gist bei Github.
Um wenigstens die Syndication-Clients nicht zu verschrecken, schubsen die folgenden Rewrite-Regeln in der Nginx-Konfig die Requests zu den alten Rss- und Atom-Feeds auf die neuen Resourcen weiter:
rewrite ^/pebble/atom.xml$ /blog/feeds/atom/ break;rewrite ^/pebble/tags/(.+)/(.+).xml$ /blog/tag/$1/feeds/$2/ break;
Alle anderen Requests zu den alten Pebble-Urls werden einfach auf die Blogübersicht weitergeleitet:<span class="mldr">&mldr;</span></p></a><p class="note labels"><a class="tag" href="/tags/mezzanine/">mezzanine</a><a class="tag" href="/tags/web/"> web</a><a class="tag" href="/tags/pebble/"> pebble</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="/post/">1</a></li><li><a class="" href="/post/page/2/">2</a></li><li><a class="" href="/post/page/3/">3</a></li></ul>
</div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">© 2008 - 2021 C. Drexler</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section></body>

</html>